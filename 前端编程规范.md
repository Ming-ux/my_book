[TOC]

## 一、单一职责    

### 单一法则   

坚持每个文件只定义一样东西（例如服务或组件）, 考虑把文件大小限制在 400 行代码以内。      

**这么做的理由：**   
单组件文件非常容易阅读、维护，并能防止在版本控制系统里与团队冲突。      
单组件文件可以防止一些隐蔽的程序缺陷，当把多个组件合写在同一个文件中时，可能造成共享变量、创建意外的闭包，或者与依赖之间产生意外耦合等情况。     
单独的组件通常是该文件默认的导出，可以用路由器实现按需加载。      
最关键的是，可以增强代码可重用性和阅读性，减少出错的可能性。


### 简单函数    

坚持定义简单函数，考虑限制在 75 行之内。      

**这么做的理由：**   
简单函数更易于测试，特别是当它们只做一件事，只为一个目的服务时。      
简单函数促进代码重用。     
简单函数更易于阅读。     
简单函数更易于维护。     
简单函数可避免易在大函数中产生的隐蔽性错误，例如与外界共享变量、创建意外的闭包或与依赖之间产生意外耦合等。     

--------------------

## 二、命名     

命名约定对可维护性和可读性非常重要。本指南为文件名和符号名推荐了一套命名约定。     

### 总体命名指导原则    

坚持所有符号使用一致的命名规则。      
坚持遵循同一个模式来描述符号的特性和类型。推荐的模式为feature.type.ts。       

**这么做的理由：**      
命名约定提供了一致的方式来查找内容，让我们一眼就能锁定。 项目的一致性是至关重要的。团队内的一致性也很重要。整个公司的一致性会提供惊人的效率。      
命名约定帮助我们更快得找到不在手头的代码，更容易理解它。    
目录名和文件名应该清楚的传递它们的意图。 例如，app/heroes/hero-list.component.ts包含了一个用来管理英雄列表的组件。     

### 使用点和横杠来分隔文件名      

坚持在描述性名字中，用横杠来分隔单词。   
坚持使用点来分隔描述性名字和类型。    
坚持遵循先描述组件特性，再描述它的类型的模式，对所有组件使用一致的类型命名规则。推荐的模式为feature.type.ts。     
坚持使用惯用的后缀来描述类型，包括*.service、*.component、*.pipe、.module、.directive。 必要时可以创建更多类型名，但必须注意，不要创建太多。       

**这么做的理由：**     
类型名字提供一致的方式来快速的识别文件中有什么。     
利用编辑器或者 IDE 的模糊搜索功能，可以很容易地找到特定文件。    
像.service这样的没有简写过的类型名字，描述清楚，毫不含糊。 像.srv, .svc, 和 .serv这样的简写可能令人困惑。      
为自动化任务提供模式匹配。      

### 符号名与文件名     

坚持为所有东西使用一致的命名约定，以它们所代表的东西命名。       
坚持使用大写驼峰命名法来命名类。符号名匹配它所在的文件名。       
坚持在符号名后面追加约定的类型后缀（例如Component、Directive、Module、Pipe、Service）。      
坚持在符号名后面追加约定的类型后缀（例如.component.ts、.directive.ts、.module.ts、.pipe.ts、.service.ts）。     
坚持在文件名后面追加约定的类型后缀（例如.component.ts、.directive.ts、.module.ts、.pipe.ts、.service.ts）。     

**这么做的理由：**      
遵循一致的约定可以快速识别和引用不同类型的资产。       

### 服务名   

坚持使用一致的规则命名服务，以它们的特性来命名。     
坚持为服务的类名加上Service后缀。 例如，获取数据或英雄列表的服务应该命名为DataService或HeroService。     

**这么做的理由：**      
提供一致的方式来快速识别和引用服务。      

### 指令选择器  

坚持使用小驼峰命名法来命名指令的选择器。      

**这么做的理由：**      
保持指令中定义的属性名与绑定的视图 HTML 属性名字一致。     
Angular HTML 解析器是大小写敏感的，它识别小写驼峰写法。      

### 为组件添加自定义前缀   

坚持使用带连字符的小写元素选择器值（例如admin-users）。     
坚持为组件选择器添加自定义前缀。 例如，toh前缀表示 Tour of Heroes（英雄指南），而前缀`admin表示管理特性区。     
坚持使用前缀来识别特性区或者应用程序本身。    

**这么做的理由：**       
防止与其它应用中的组件和原生 HTML 元素发生命名冲突。      
更容易在其它应用中推广和共享组件。      
组件在 DOM 中更容易被区分出来。       

```
# app/users/users.component.ts   
@Component({
  selector: 'admin-users'    # 这里为users添加一个前缀 admin
})
export class UsersComponent {}
```

### 为指令添加自定义前缀    

坚持为指令的选择器添加自定义前缀（例如前缀toh来自Tour of Heroes）。        
坚持用小驼峰形式拼写非元素选择器，除非该选择器用于匹配原生 HTML 属性。      

**这么做的理由：**        
防止名字冲突。      
指令更加容易被识别。       
```
@Directive({
  selector: '[tohValidate]'    # 为 Validate 添加一个前缀toh
})
export class ValidateDirective {}
```

### 管道名     

坚持为所有管道使用一致的命名约定，用它们的特性来命名。       

**这么做的理由：**        
提供一致方式快速识别和引用管道。        

### 单元测试文件名        

坚持测试规格文件名与被测试组件文件名相同。        
坚持测试规格文件名添加.spec后缀。          

**这么做的理由：**         
提供一致的方式来快速识别测试。         
提供一个与 karma 或者其它测试运行器相配的命名模式。         

###  端到端测试文件名       

坚持端到端测试规格文件和它们所测试的特性同名，添加.e2e-spec后缀。         

**这么做的理由：**         
提供一致的方式快速识别端到端测试文件。        
提供一个与测试运行器和构建自动化匹配的模式。          
```
app.e2e-spec.ts
heroes.e2e-spec.ts
```

### Angular NgModule 命名       

坚持为符号名添加Module后缀.         
坚持为文件名添加.module.ts扩展名。         
坚持用特性名和所在目录命名模块。
坚持为 RoutingModule 类名添加RoutingModule后缀。       
坚持为 RoutingModule 的文件名添加-routing.module.ts后缀。

**这么做的理由：**          
提供一致的方式来快速标识和引用模块。          
大驼峰命名法是一种命名约定，用来标识可用构造函数实例化的对象。           
很容易就能看出这个模块是同名特性的根模块。        
RoutingModule是一种专门用来配置 Angular 路由器的模块。 “类名和文件名保持一致”的约定使这些模块易于发现和验证。
```
# app.module.ts 
@NgModule({ ... })
export class AppModule { }    

# heroes.module.ts
@NgModule({ ... })
export class HeroesModule { }

# villains.module.ts
@NgModule({ ... })
export class VillainsModule { }

# app-routing.module.ts
@NgModule({ ... })
export class AppRoutingModule { }

# heroes-routing.module.ts
@NgModule({ ... })
export class HeroesRoutingModule { }

```    

--------------

## 编程约定    

坚持一致的编程、命名和空格的约定。

### 类    

坚持使用大写驼峰命名法来命名类。      

**这么做的理由：**          
遵循类命名传统约定。         
类可以被实例化和构造实例。根据约定，用大写驼峰命名法来标识可构造的东西。         
```
export class ExceptionService {
  constructor() { }
}
```     

### 常量       

坚持用const声明变量，除非它们的值在应用的生命周期内会发生变化。        
考虑 把常量名拼写为小驼峰格式。       
坚持容许现存的const常量沿用大写蛇形命名法。

**这么做的理由：**      
告诉读者这个值是不可变的。        
TypeScript 会要求在声明时立即初始化，并阻止再次赋值，以确保达成我们的意图。      
小驼峰变量名 (heroRoutes) 比传统的大写蛇形命名法 (HERO_ROUTES) 更容易阅读和理解。         
把常量命名为大写蛇形命名法的传统源于现代 IDE 出现之前， 以便阅读时可以快速发现那些const定义。 TypeScript 本身就能够防止意外赋值。         
传统的大写蛇形命名法仍然很流行、很普遍，特别是在第三方模块中。 修改它们没多大价值，还会有破坏现有代码和文档的风险。         
```
export const mockHeroes   = ['Sam', 'Jill']; // prefer
export const heroesUrl    = 'api/heroes';    // prefer
export const VILLAINS_URL = 'api/villains';  // tolerate
```

### 接口       

坚持使用大写驼峰命名法来命名接口。         
考虑不要在接口名字前面加I前缀。         
考虑用类代替接口。         

**这么做的理由：**       
[TypeScript 指导原则](https://github.com/Microsoft/TypeScript/wiki/Coding-guidelines)不建议使用 “I” 前缀。     
单独一个类的代码量小于类+接口。         
类可以作为接口使用（只是用implements代替extends而已）。         
在 Angular 依赖注入系统中，接口类可以作为服务提供商的查找令牌。        
```
# app/shared/hero-collector.service.ts
import { Injectable } from '@angular/core';
import { Hero } from './hero.model';
@Injectable()
export class HeroCollectorService {
  hero: Hero;
  constructor() { }
}
```

### 属性和方法      

坚持使用小写驼峰命名法来命名属性和方法。           
避免为私有属性和方法添加下划线前缀。         

**这么做的理由：**        
遵循传统属性和方法的命名约定。           
JavaScript 不支持真正的私有属性和方法。         
TypeScript 工具让识别私有或公有属性和方法变得很简单。           
```
# app/shared/toast.service.ts
import { Injectable } from '@angular/core';
@Injectable()
export class ToastService {
  message: string;
  private toastCount: number;
  hide() {
    this.toastCount--;
    this.log();
  }
  show() {
    this.toastCount++;
    this.log();
  }
  private log() {
    console.log(this.message);
  }
}
```

### 导入语句中的空行         

坚持在第三方导入和应用导入之间留一个空行。        
考虑按模块名字的字母顺排列导入行。           
考虑在解构表达式中按字母顺序排列导入的东西。        

**这么做的理由：**         
空行可以让阅读和定位本地导入更加容易。        
按字母顺序排列可以让阅读和定位本地导入更加容易。        
```
# app/heroes/shared/hero.service.ts
import { Injectable } from '@angular/core';
import { Http }       from '@angular/http';

import { Hero } from './hero.model';
import { ExceptionService, SpinnerService, ToastService } from '../../core';
```

## 应用程序结构与 Angular 模块         

准备一个近期实施方案和一个长期的愿景。从零开始，但要考虑应用程序接下来的路往哪儿走。         

所有应用程序的源代码都放到名叫src的目录里。 所有特性区都在自己的文件夹中，带有它们自己的 Angular 模块。         

所有内容都遵循每个文件一个特性的原则。每个组件、服务和管道都在自己的文件里。 所有第三方程序包保存到其它目录里，而不是src目录。 你不会修改它们，所以不希望它们弄乱我们的应用程序。 使用本指南介绍的文件命名约定。